#!/usr/bin/env groovy
@Library('apm@current') _

pipeline {
  agent { label 'linux && immutable' }
  environment {
    REPO = 'apm-agent-nodejs'
    BASE_DIR = "src/github.com/elastic/${env.REPO}"
    PIPELINE_LOG_LEVEL='INFO'
    JOB_GCS_BUCKET = credentials('gcs-bucket')
    GITHUB_CHECK = 'true'
    RELEASE_URL_MESSAGE = "(<https://github.com/elastic/${env.REPO}/releases/tag/${env.TAG_NAME}|${env.TAG_NAME}>)"
    SLACK_CHANNEL = '#apm-agent-node'
    NOTIFY_TO = 'build-apm+apm-agent-nodejs@elastic.co'
    NPMRC_SECRET = 'secret/jenkins-ci/npmjs/elasticmachine'
    TOTP_SECRET = 'totp/code/npmjs-elasticmachine'
    BUILD_NODE_VERSION = 'v16.15.1'
    DOCKER_REGISTRY = 'docker.elastic.co'
    DOCKER_SECRET = 'secret/apm-team/ci/docker-registry/prod'
  }
  options {
    timeout(time: 3, unit: 'HOURS')
    buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '20', daysToKeepStr: '30'))
    timestamps()
    ansiColor('xterm')
    disableResume()
    durabilityHint('PERFORMANCE_OPTIMIZED')
    rateLimitBuilds(throttle: [count: 60, durationName: 'hour', userBoost: true])
    quietPeriod(10)
  }
  triggers {
    issueCommentTrigger("(${obltGitHubComments()}|^run benchmark tests.*)")
  }
  parameters {
    booleanParam(name: 'bench_ci', defaultValue: true, description: 'Enable benchmarks.')
  }
  stages {
    /**
    Checkout the code and stash it, to use it on other stages.
    */
    stage('Checkout') {
      options { skipDefaultCheckout() }
      steps {
        pipelineManager([ cancelPreviousRunningBuilds: [ when: 'PR' ] ])
        deleteDir()
        gitCheckout(basedir: "${BASE_DIR}", githubNotifyFirstTimeContributor: true,
                    shallow: false, reference: "/var/lib/jenkins/.git-references/${REPO}.git")
        stash allowEmpty: true, name: 'source', useDefaultExcludes: false
      }
    }
    stage('Release') {
      options { skipDefaultCheckout() }
      when {
        beforeAgent true
        tag pattern: 'v\\d+\\.\\d+\\.\\d+', comparator: 'REGEXP'
      }
      environment {
        HOME = "${env.WORKSPACE}" // required by "bash_standard_lib.sh" for "Push Docker Image" step
        SUFFIX_ARN_FILE = 'arn-file.md'
      }
      stages {
        stage('Dist') {
          steps {
            withGithubNotify(context: "Dist") {
              setEnvVar('ELASTIC_LAYER_NAME', "elastic-apm-node${getVersion()}")
              setEnvVar('RELEASE_NOTES_URL', getReleaseNotesUrl())
              deleteDir()
              unstash 'source'
              withNodeJSEnv(version: "${env.BUILD_NODE_VERSION}"){
                dir("${BASE_DIR}"){
                  cmd(label: 'make dist', script: 'make -C .ci dist')
                }
              }
            }
          }
        }
        stage('Push Docker Image') {
          steps {
            withGithubNotify(context: "Push-Docker-Image") {
              dir("${BASE_DIR}"){
                dockerLogin(secret: "${env.DOCKER_SECRET}", registry: "${env.DOCKER_REGISTRY}")
                cmd(label: 'make push-docker', script: 'make -C .ci push-docker')
              }
            }
          }
        }
        stage('Publish to AWS') {
          steps {
            withGithubNotify(context: "Publish") {
              withGoEnv(){
                withAWSEnv(secret: 'secret/observability-team/ci/service-account/apm-aws-lambda', forceInstallation: true, version: '2.4.10') {
                  dir("${BASE_DIR}"){
                    cmd(label: 'make publish-in-all-aws-regions', script: 'make -C .ci publish-in-all-aws-regions')
                    cmd(label: 'make create-arn-file', script: 'make -C .ci create-arn-file')
                  }
                }
              }
            }
          }
          post {
            always {
              archiveArtifacts(allowEmptyArchive: true, artifacts: "${BASE_DIR}/build/aws")
            }
          }
        }
        stage('GitHub Release') {
          steps {
            withGhEnv(forceInstallation: true, version: '2.4.0') {
              dir("${BASE_DIR}"){
                cmd(label: 'make github-release', script: 'make -C .ci github-release')
              }
            }
          }
        }
        stage('Publish to npm') {
          steps {
            withNodeJSEnv(version: "${env.BUILD_NODE_VERSION}") {
              withNpmrc(secret: "${env.NPMRC_SECRET}", path: "${env.WORKSPACE}/${env.BASE_DIR}") {
                withTotpVault(secret: "${env.TOTP_SECRET}", code_var_name: 'TOTP_CODE') {
                  dir("${BASE_DIR}") {
                    sh(label: 'npm-publish', script: "npm publish --otp=${env.TOTP_CODE}")
                  }
                }
              }
            }
          }
        }
      }
      post {
        success {
          whenTrue(isTag()) {
            notifyStatus(slackStatus: 'good', subject: "[${env.REPO}] Release *${env.TAG_NAME}* published", body: "Build: (<${env.RUN_DISPLAY_URL}|here>)\nRelease URL: ${env.RELEASE_URL_MESSAGE}")
          }
        }
        failure {
          whenTrue(isTag()) {
            notifyStatus(slackStatus: 'warning', subject: "[${env.REPO}] Release *${env.TAG_NAME}* could not be published.", body: "Build: (<${env.RUN_DISPLAY_URL}|here>)")
          }
        }
      }
    }
    /**
      Run the benchmarks and store the results on ES.
      The result JSON files are also archive into Jenkins.
    */
    stage('Benchmarks') {
      agent { label 'microbenchmarks-pool' }
      options { skipDefaultCheckout() }
      environment {
        HOME = "${env.WORKSPACE}"
        RESULT_FILE = 'apm-agent-benchmark-results.json'
        NODE_VERSION = '14'
      }
      when {
        beforeAgent true
        allOf {
          anyOf {
            branch 'main'
            expression { return env.GITHUB_COMMENT?.contains('benchmark tests') }
          }
          expression { return params.bench_ci }
        }
      }
      steps {
        withGithubNotify(context: 'Benchmarks', tab: 'artifacts') {
          dir(env.BUILD_NUMBER) {
            deleteDir()
            unstash 'source'
            dir(BASE_DIR){
              sh '.ci/scripts/run-benchmarks.sh "${RESULT_FILE}" "${NODE_VERSION}"'
            }
          }
        }
      }
      post {
        always {
          catchError(message: 'sendBenchmarks failed', buildResult: 'FAILURE') {
            sendBenchmarks(file: "${BUILD_NUMBER}/${BASE_DIR}/${RESULT_FILE}",
                           index: 'benchmark-nodejs', archive: true)
          }
          catchError(message: 'deleteDir failed', buildResult: 'SUCCESS', stageResult: 'UNSTABLE') {
            deleteDir()
          }
        }
      }
    }
  }
  post {
    cleanup {
      notifyBuildResult()
    }
  }
}

/**
* Transform TAG releases from v{major}.{minor}.{patch} to
* ver-{major}-{minor}-{patch}. e.g: given v1.2.3 then
* -ver-1-2-3.
*/
def getVersion() {
  if (env.BRANCH_NAME?.trim() && env.BRANCH_NAME.startsWith('v')) {
    return env.BRANCH_NAME.replaceAll('v', '-ver-').replaceAll('\\.', '-')
  }
  return ''
}

/**
* Calculate the elastic.co release notes URL given the TAG release. Otherwise
* it returns the default current URL.
*/
def getReleaseNotesUrl() {
  def baseUrl = 'https://www.elastic.co/guide/en/apm/agent/nodejs/current'
  if (env.BRANCH_NAME?.trim() && env.BRANCH_NAME.startsWith('v')) {
    def version = env.BRANCH_NAME.replaceAll('v', '')
    def parts = version.split('\\.')
    def major = parts[0]
    return "${baseUrl}/release-notes-${major}.x.html#release-notes-${version}"
  }
  return baseUrl
}

def notifyStatus(def args = [:]) {
  releaseNotification(slackChannel: "${env.SLACK_CHANNEL}",
                      slackColor: args.slackStatus,
                      slackCredentialsId: 'jenkins-slack-integration-token',
                      to: "${env.NOTIFY_TO}",
                      subject: args.subject,
                      body: args.body)
}
